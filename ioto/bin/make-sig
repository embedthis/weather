#!/usr/bin/env node
/*
    make-sig [--blend Object=file ...] input.json5 output.json5

    Prepare a JSON5 signature file for use in the API.
    This blends in the schema files and removes all descriptions.
 */

var Fs = require('fs')
var Path = require('path')

function json5(file) {
    let obj
    let data = 'obj = ' + Fs.readFileSync(file, 'utf8')
    try {
        eval(data)
    } catch (err) {
        console.error('Cannot parse', file, err.message)
        process.exit(2)
    }
    return obj
}

let args = process.argv.slice(2)
let schema = null

let i = 0
for (i = 0; i < args.length; i++) {
    let arg = args[i]
    if (arg == '--blend') {
        let [key, value] = args[++i].split('=')
        global[key] = include(value)
    } else if (arg == '--schema') {
        let value = args[++i]
        schema = include(value)
    } else {
        break
    }
}
let [input, output] = args.slice(i)

if (!input || !output) {
    console.error(`Usage: api [--blend file] input.js output.json doc/dir`)
    process.exit(2)
}

async function main() {
    let path = Path.join(process.cwd(), input)
    let signatures = include(path)
    cleanSignatures(signatures)
    if (schema) {
        blendSchema(signatures, schema)
    }

    let data = JSON.stringify(signatures, null, 4) + '\n'
    data = compressJson5(data, 6, 80)
    try {
        let old = Fs.readFileSync(output).toString()
        if (data == old) {
            return
        }
    } catch (err) { }
    console.log('  [Exported]', Path.basename(output))
    Fs.writeFileSync(output, data)
}

function blendSchema(signatures, schema) {
    let models = signatures._models_ || (signatures._models_ = {})
    for (let [name, fields] of Object.entries(schema.models)) {
        delete fields.pk
        delete fields.sk
        for (let [key, field] of Object.entries(fields)) {
            if (field.hidden) {
                delete field[key]
            }
        }
        models[name] = { fields }
    }
}

/*
    Remove all descriptions from the signatures
 */
function cleanSignatures(signatures) {
    for (let [name, model] of Object.entries(signatures)) {
        delete model._meta?.description
        for (let [methodName, method] of Object.entries(model)) {
            delete method.description
            for (let item of ['request', 'response']) {
                let block = method[item]
                if (block) {
                    cleanBlock(block, block)
                }
            }
        }
    }
}

function cleanBlock(block, parent) {
    delete block.description
    if (block.fields) {
        for (let [key, field] of Object.entries(block.fields)) {
            if (field.drop) {
                block.hasDrop = true
            }
            if (field.required || field.default) {
                block.hasRequired = true
            }
            if (key == '*') {
                block.hasWild = true
            }
            cleanBlock(field, parent)
        }
    }
    if (block.of) {
        cleanBlock(block.of, parent)
    }
    if (block.query) {
        cleanBlock(block.query, parent)
    }
}

function include(path) {
    let data = json5(path)
    if (!data.blend) return data
    for (let file of data.blend) {
        file = Path.resolve(path, file)
        data = blend(data, include(file))
    }
    delete data.blend
    return data
}

function clone(src) {
    var result
    if (Array.isArray(src)) {
        result = src.slice(0)
    } else if (typeof src == 'object' && !(src instanceof Date || src instanceof RegExp || src == null)) {
        result = Object.create(Object.getPrototypeOf(src))
        var i, descriptor, keys = Object.getOwnPropertyNames(src)
        for (i = 0; i < keys.length; i ++) {
            descriptor = Object.getOwnPropertyDescriptor(src, keys[ i ])
            if (descriptor.value && typeof descriptor.value === 'object') {
                descriptor.value = clone(descriptor.value)
            }
            Object.defineProperty(result, keys[i], descriptor)
        }
    } else {
        result = src
    }
    return result
}

function blend(dest, src, combine = '') {
    if (!src) {
        return dest
    }
    if (!dest || typeof dest != 'object' || Array.isArray(dest)) {
        return dest
    }
    for (let key of Object.getOwnPropertyNames(src)) {
        let property = key
        let op = key[0]
        if (op == '+') {
            property = key.slice(1)
        } else if (op == '-') {
            property = key.slice(1)
        } else if (op == '?') {
            property = key.slice(1)
        } else if (op == '=') {
            property = key.slice(1)
        } else if (combine) {
            op = combine
        } else {
            /* Default is to blend */
            op = ''
        }
        let s = src[key]
        if (!dest.hasOwnProperty(property)) {
            if (op == '-') {
                continue
            }
            dest[property] = clone(s)
            continue
        } else if (op == '?') {
            continue
        }
        let d = dest[property]
        if (Array.isArray(d)) {
            if (op == '+') {
                if (Array.isArray(s)) {
                    for (let item of s) {
                        if (d.indexOf(s) < 0) d.push(item)
                    }
                } else {
                    d.push(s)
                }
            } else if (op == '-') {
                if (Array.isArray(s)) {
                    for (let item of s) {
                        let index = d.indexOf(item)
                        if (index >= 0) d.slice(index, 1)
                    }
                } else {
                    let index = d.indexOf(s)
                    if (index >= 0) d.slice(index, 1)
                }
            } else {
                /* op == '=' */
                dest[property] = clone(s)
            }
        } else if (typeof d == 'object' && d !== null && d !== undefined) {
            if (op == '=') {
                dest[property] = clone(s)
            } else if (op == '-') {
                delete dest[property]
            } else if (typeof s == 'object') {
                blend(d, s, op)
            }
        } else if (typeof d == 'string') {
            if (op == '+') {
                dest[property] += ' ' + s
            } else if (op == '-') {
                if (d == s) {
                    delete dest[property]
                } else {
                    dest[property] = d.replace(s, '')
                }
            } else {
                /* op == '=' */
                dest[property] = s
            }
        } else if (typeof d == 'number') {
            if (op == '+') {
                dest[property] += s
            } else if (op == '-') {
                dest[property] -= s
            } else {
                /* op == '=' */
                dest[property] = s
            }
        } else {
            if (op == '=') {
                dest[property] = s
            } else if (op == '-') {
                delete dest[property]
            } else {
                dest[property] = s
            }
        }
    }
    return dest
}

function compressJson5(src, maxItems = 6, maxLen = 80) {
    if (!src) {
        return ''
    }
    // Strip comments
    src = src.replace(/\s*\/\/.*/g, '')

    let prev
    // Iteratively compress, working from the inside out.
    // This loop will repeat until no more changes can be made, up to 8 times.
    for (let i = 0; i < 8; i++) {
        prev = src

        // Regex to find a "simple" object or array: one that does not contain other objects or arrays.
        // It looks for an opening brace/bracket, followed by any characters that are NOT braces/brackets,
        // and then the corresponding closing brace/bracket. This finds the innermost structures.
        const re = /([{[])([^[{}]*?)([}\]])/g
        src = src.replace(re, (match, open, body, close) => {
            // If the structure isn't multi-line, we don't need to change it.
            if (!match.includes('\n')) {
                return match
            }

            // Don't modify if opening and closing braces don't match
            if ((open === '{' && close !== '}') || (open === '[' && close !== ']')) {
                return match
            }

            const trimmedBody = body.trim()
            if (trimmedBody === '') {
                return `${open}${close}`
            }

            // To check item count, we can split by comma.
            // This is a simplification and works for many JSON5-like structures.
            const items = trimmedBody.split(',').filter(s => s.trim())
            if (items.length > maxItems) {
                return match
            }
            
            // Re-join items onto a single line
            const oneline = `${open} ${items.join(', ').replace(/\s+/g, ' ')} ${close}`
            if (oneline.length > maxLen) {
                return match
            }

            return oneline
        })

        if (src === prev) {
            break
        }
    }
    return src
}

main()
